"""
Module for plotting model results.

Generates HTML figures produced using plotly library.
"""



from core.OutputProcessing import SolutionInterface
from core.Settings import Settings
from core.InputProcessing import OsemosysInputGenerator

import plotly.graph_objects as go
import plotly.colors as plc

import pandas as pd
import numpy as np

import random
import os

from typing import List


class ResPlottingException(Exception):
    """
    Class for throwing Exceptions by the plotting engine
    """
    pass


def _hex_to_rgba(hexarray, alpha):
    ret = []
    for col in hexarray:
        color_tuple = plc.hex_to_rgb(col)
        ret.append("rgba(%s, %s, %s, %s)" %(*color_tuple, alpha))
    return ret


class OsemosysPlottingEngine:
    """Plotting Engine.

    Args:
        sim_dir(str): Simulation directory generated by the Model Runner engine
        compute_missing_variables(bool, optional): Compute missing intermediate variables. Default False.
                                                   If True and OsemosysModel object will be created from the input file in the simulation folder.
                                                   This will make the object initialization slower.
    Raises:
        ResPlottingException: Error during the execution of a plot method.
    """
    def __init__(self, sim_dir, compute_missing_variables=False):

        self.sim_dir = sim_dir
        self.sett = Settings(os.sep.join([sim_dir, "settings.ini"]))

        self.compute_missing_variables = compute_missing_variables
        if self.compute_missing_variables:
            self.input_generator = OsemosysInputGenerator.build_from_input_file(sim_dir)
            self.default_call = dict(compute_missing_vars=True, input_generator=self.input_generator)
        else:
            self.default_call= dict()

        self._plot_sett = pd.read_csv(os.sep.join([sim_dir, "plotSettings.csv"]))

        self.sol = self._initialize_solution_interface()

    def plot_annual_supply(self, fuel):
        """Plot annual energy supply of a fuel.

        Bar plot of the annual energy supply of a given fuel by year. Stacked by technology.

        Args:
            fuel(str): Name of fuel as defined in the model. CASE SENSITIVE.
        """
        kwargs = self.default_call.copy()
        kwargs["var"]="ProductionByTechnologyAnnual"
        kwargs["select"] = dict(FUEL=fuel)

        df = self.sol.get_var_values(**kwargs)

        layout = self._get_default_layout(title="Annual %s Production by Technology" % fuel, yaxistitle="TWh/a",
                                          xaxistitle="Year")
        traces = self._get_traces(df)

        f = go.Figure(data=traces, layout=layout)
        f.show()

    def plot_annual_use(self, fuel):
        """Plot annual energy consumption of a fuel.

        Bar plot of the annual energy consumption of a given fuel by year. Stacked by technology.
        Usable energy demand not included!!

        Args:
            fuel(str): Name of fuel as defined in the model. CASE SENSITIVE.

        Todo:
            Add usable energy demand to the plot.

        """
        kwargs = self.default_call.copy()
        kwargs["var"] = "UseByTechnologyAnnual"
        kwargs["select"] = dict(FUEL=fuel)

        df = self.sol.get_var_values(**kwargs)
        layout = self._get_default_layout(title="Annual %s Use by Technology" % fuel, yaxistitle="TWh/a",
                                          xaxistitle="Year")
        traces = self._get_traces(df)
        f = go.Figure(layout=layout, data=traces)
        f.show()

    def plot_annual_active_capacities(self):
        """Plot annual active capacities

        Bar plot active capacities by year. Stacked by technology.

        Todo:
            Implement selection by output energy form.

        """
        df = self.sol.get_var_values("TotalCapacityAnnual", **self.default_call)
        layout = self._get_default_layout(title="Annual Active Capacity", yaxistitle="GW", xaxistitle="Year")
        traces = self._get_traces(df)
        f = go.Figure(layout=layout, data=traces)
        f.show()

    def plot_annual_emissions(self):
        """ Plot annual emissions.

        Bar plot of the emissions by year, stacked by emission type.

        """
        df = self.sol.get_var_values("AnnualEmissions", **self.default_call)
        layout = self._get_default_layout(title="Annual Emissions", yaxistitle="mio. t/a", xaxistitle="Year")
        traces = self._get_traces(df, stacks="EMISSION")
        f = go.Figure(layout=layout, data=traces)
        f.show()

    def plot_supply_timeseries(self, fuel, year):
        """
        Plot the timeslice depended supply of a fuel in a year.

        Area plot of the supply of a fuel by the timeslices, stacked by technology.
        The values are corrected with the timeslices weights to represent the actual power output of the process.

        Args:
            fuel(str): Name of fuel as defined in the model. CASE SENSITIVE.
            year(str): Year to be plotted

        """
        year = int(year)
        self._plot_annual_timeseries(type="supply", fuel=fuel, year=year)

    def plot_sankey(self, year):
        """
        Plot sankey diagram of a year.

        Args:
            year(str): Year to be plotted

        """

        link_opacity = self.sett.sankey_opacity
        year = int(year)

        kwargs = self.default_call.copy()
        kwargs["select"] = dict(YEAR=year)

        # Take all Total Energy Use: Source InputFuel, target Technology
        kwargs["var"] = "UseByTechnologyAnnual"
        ein = self.sol.get_var_values(**kwargs)
        ein.rename(columns={"TECHNOLOGY": "target", "FUEL": "source","VALUE": "level"}, inplace=True)

        # Take all Pout: Source cp, target Cout /  remove secondary
        kwargs["var"] = "ProductionByTechnologyAnnual"
        eout = self.sol.get_var_values(**kwargs)
        fuels = list(eout["FUEL"])
        eout.rename(columns={"TECHNOLOGY": "source", "FUEL": "target", "VALUE": "level"}, inplace=True)


        # Take Demands
        kwargs["var"] = "Demand"
        demand = self.sol.get_var_values(**kwargs)
        demand = demand.groupby(["YEAR", "FUEL"], as_index= False).sum()
        demand["target"] = demand["FUEL"].apply(lambda x: "Demand %s"%x)
        demand.rename(columns={"FUEL": "source", "VALUE": "level"}, inplace=True)

        # Join Dfs
        df = pd.concat([ein.loc[:, ["source", "target", "level"]], eout.loc[:, ["source", "target", "level"]], demand.loc[:, ["source", "target", "level"]]])
        if len(df) == 0:
            raise ResPlottingException("Nothing to plot")


        # Plot
        nodes = list(df["source"]) + list(df["target"])
        nodes = list(set(nodes))
        id_fun = lambda x: nodes.index(x)
        df["source_i"] = df["source"].apply(id_fun)
        df["target_i"] = df["target"].apply(id_fun)

        # Apply Colors
        recolor = dict()

        for n in nodes:
            recolor[n] = self._get_color(n)

        assign_link_color = lambda x: recolor[x[0]] if x[0] in fuels else recolor[x[1]]
        df["color"] = df[["target", "source"]].apply(assign_link_color, axis=1)

        df["color"] = _hex_to_rgba(hexarray=list(df["color"]), alpha=link_opacity)
        node_color = lambda node: recolor[node] if node in fuels else "rgb(100,100,100)"

        fig = go.Figure(data=[go.Sankey(
            arrangement='perpendicular',
            node=dict(
                # pad=30,
                thickness=10,
                line=dict(color="black", width=0.01),
                label=nodes,
                color=[node_color(n) for n in nodes]
                #color="rgb(150,150,150)"
            ),
            link=dict(
                source=df["source_i"],
                target=df["target_i"],
                value=df["level"],
                color=df["color"],
            ))])

        fig.update_layout(title_text="%s Sankey"%year, font_size=12)

        fig.show()

        return fig

    def plot_use_timeseries(self, fuel, year):
        """
        Plot the timeslice depended consumption of a fuel in a year.

        Area plot of the consumption of a fuel by the timeslices, stacked by technology.
        The demand is also included in the plot.
        The values are corrected with the timeslices weights to represent the actual power output of the process.

        Args:
            fuel(str): Name of fuel as defined in the model. CASE SENSITIVE.
            year(str): Year to be plotted

        """

        year = int(year)
        self._plot_annual_timeseries(type="use", fuel=fuel, year=year)

    def _plot_annual_timeseries(self, type, fuel, year):
        stacks = "TECHNOLOGY"
        if type == "supply":
            vars = ["RateOfProductionByTechnology"]
        elif type == "use":
            vars = ["RateOfUseByTechnology", "RateOfDemand"]
        elif type == ["demand"]:
            vars = "RateOfDemand"
            stacks="FUEL"
        else:
            raise ResPlottingException("Invalid timeseries plot type")
            pass

        dfs = []
        for var in vars:
            dfs.append(self.sol.get_var_values(var, select=dict(FUEL=fuel, YEAR=year), **self.default_call))
        df = pd.concat(dfs)

        df["TECHNOLOGY"].fillna("Demand %s" % fuel, inplace=True)

        #Correct Units (Divide values by Capacity to activity unit)
        df["VALUE"] = df["VALUE"].apply(lambda x: x/8.76)
        time_slices = df["TIMESLICE"].unique()

        df.loc[:,"TIMESTEP"] = df["TIMESLICE"].apply(lambda x: int(np.where(time_slices == x)[0]))

        layout = self._get_default_layout(title="%s %s Timeseries %s " % (fuel, type, year), yaxistitle="GW",
                                          xaxistitle="Simulation Timestep")
        traces = self._get_traces(df, x="TIMESTEP", stacks=stacks, type="timeseries")

        f = go.Figure(data=traces, layout=layout)
        f.show()

    def _get_traces(self, df, x="YEAR", y="VALUE", stacks="TECHNOLOGY", type="bar") -> List[go.Figure]:

        if df.size == 0:
            raise ResPlottingException("No results to plot!")

        traces = []
        df.loc[:, "stacks_sorting"] = df[stacks].apply(lambda x: self._get_order(x))
        df = df.sort_values(by=["stacks_sorting"], ascending=[True])

        for st, in zip(df[stacks].unique()):
            plot_df = df[df[stacks] == st]
            if type == "bar":
                t = go.Bar(x=plot_df[x], y=plot_df[y], name=st, marker_color=self._get_color(st))
            elif type == "timeseries":
                t = go.Scatter(x = plot_df[x], y=plot_df[y], name=st, stackgroup="one",
                               mode="none", fillcolor=self._get_color(st))
            else:
                raise ResPlottingException("Invalid type for plotting!")
            traces.append(t)
        return traces

    def _initialize_solution_interface(self) -> SolutionInterface:
        if self.sett.solver == "GLPK":
            dir = os.sep.join([self.sim_dir, self.sett.glpk_solutions_dir])
        elif self.sett.solver == "CPLEX":
            dir = os.sep.join([self.sim_dir, self.sett.cplex_solutions_dir])
        else:
            raise ResPlottingException("Results from solver %s cannot be plotted" % self.sett.solver)
        return SolutionInterface(sol_dir=dir)

    def _get_default_layout(self, title=None, yaxistitle=None, xaxistitle="Year"):
        return go.Layout(
            showlegend=True,
            font_family="Knuth's Computer Modern",
            # template="plotly_white",
            title=title,
            xaxis=dict(title_text=xaxistitle),
            yaxis=dict(title_text=yaxistitle),
            barmode="stack",
            # width=700,
            # height=500,
        )

    def _get_color(self, p):
        colors = self._plot_sett["Item"].values
        # If color is defined for p
        aux = colors == p
        if any(aux):
            return self._plot_sett.loc[aux, "Color"].values[0]
        else:
            return self._rand_hex_color()

    def _get_order(self, p):
        items = self._plot_sett["Item"].values
        # If color is defined for p
        aux = items == p
        if any(aux):
            return self._plot_sett.loc[aux, "Order"].values[0]
        else:
            return 20

    @staticmethod
    def _rand_hex_color():
        return "#{:06x}".format(random.randint(0, 0xFFFFFF))


if __name__ == '__main__':
    a = OsemosysPlottingEngine("../runs/DE-Model_test", compute_missing_variables=True)
    #a.plot_annual_supply("Electricity")
    #a.plot_annual_use("NaturalGas")
    # a.plot_annual_active_capacities()
    # a.plot_annual_emissions()
    a.plot_sankey("2015")
    print("END")
